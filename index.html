<!DOCTYPE html>
<html lang="en">
<head>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        // Add code loading functionality
        async function loadCodeSnippet(filePath, codeBlockId) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`Failed to load code snippet: ${response.status} ${response.statusText}`);
                }
                const code = await response.text();
                const codeElement = document.getElementById(codeBlockId);
                if (codeElement) {
                    codeElement.textContent = code;
                    hljs.highlightElement(codeElement);
                } else {
                    console.error(`Code element with ID ${codeBlockId} not found`);
                }
            } catch (error) {
                console.error('Error loading code snippet:', error);
                const codeElement = document.getElementById(codeBlockId);
                if (codeElement) {
                    codeElement.textContent = `// Error loading code snippet: ${error.message}`;
                    hljs.highlightElement(codeElement);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight any pre-filled code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Load all code snippets that have data attributes
            document.querySelectorAll('code[data-src]').forEach((codeBlock) => {
                const filePath = codeBlock.getAttribute('data-src');
                loadCodeSnippet(filePath, codeBlock.id);
            });
        });
    </script>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard Synthesizer with Drums and GUI</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        
        .author-info {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        .author-image {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
            background-color: #ddd;
        }
        
        .author-details {
            text-align: left;
        }
        
        .author-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .post-date {
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        .featured-image {
            width: 100%;
            height: 400px;
            object-fit: cover;
            margin-bottom: 30px;
            background-color: #ddd;
        }
        
        section {
            margin-bottom: 40px;
        }
        
        h2 {
            color: #3498db;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        
        p {
            margin-bottom: 20px;
        }
        
        .project-image {
            width: 100%;
            max-height: 350px;
            object-fit: contain;
            margin: 20px 0;
            background-color: #ddd;
        }
        
        .caption {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            margin-top: 5px;
            margin-bottom: 30px;
        }
        
        blockquote {
            border-left: 5px solid #3498db;
            padding-left: 20px;
            margin-left: 0;
            color: #555;
            font-style: italic;
        }
        
        .conclusion {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-top: 40px;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .components-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0 30px 0;
        }

        .components-table th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }

        .components-table td {
            padding: 8px 10px;
            border: 1px solid #ddd;
            vertical-align: top;
        }

        .components-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .components-table tr:hover {
            background-color: #e9f7fe;
        }
        pre {
            background-color: #282c34;
            border: 1px solid #3e4451;
            border-left: 3px solid #3498db;
            color: #abb2bf;
            page-break-inside: avoid;
            font-family: "SFMono-Regular", Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 1.6em;
            max-width: 100%;
            overflow: auto;
            padding: 1em 1.5em;
            display: block;
            word-wrap: break-word;
            border-radius: 0 0 4px 4px;
            max-height: 400px; /* Makes it scrollable after this height */
        }

        code {
            font-family: "SFMono-Regular", Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
            background-color: #f0f0f0;
            border-radius: 3px;
            padding: 2px 4px;
            color: #e06c75; /* Inline code color */
        }

        pre code {
            background-color: transparent;
            border-radius: 0;
            padding: 0;
            color: inherit;
        }

        .code-header {
            background-color: #3498db;
            color: white;
            padding: 8px 15px;
            font-family: "SFMono-Regular", Consolas, Monaco, monospace;
            font-weight: bold;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            margin-bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-container {
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* Syntax highlighting colors - basic set */
        .hljs-keyword { color: #c678dd; } /* purple */
        .hljs-built_in { color: #e6c07b; } /* yellow-ish */
        .hljs-type { color: #e6c07b; } /* yellow-ish */
        .hljs-literal { color: #56b6c2; } /* teal */
        .hljs-number { color: #d19a66; } /* orange */
        .hljs-regexp { color: #98c379; } /* green */
        .hljs-string { color: #98c379; } /* green */
        .hljs-subst { color: #e06c75; } /* red */
        .hljs-symbol { color: #61aeee; } /* blue */
        .hljs-class { color: #e6c07b; } /* yellow-ish */
        .hljs-function { color: #61aeee; } /* blue */
        .hljs-title { color: #61aeee; } /* blue */
        .hljs-params { color: #abb2bf; } /* default text */
        .hljs-comment { color: #5c6370; font-style: italic; } /* gray, italicized */
    </style>
</head>
<body>
    <header>
        <h1>Keyboard Synthesizer with Drums and GUI</h1>
        <div class="subtitle">3C10 Group 7</div>
        
        <div class="author-info">
            <img src="imgs/declan.png" alt="Author photo" class="author-image">
            <div class="author-details">
                <div class="author-name">Ruairi, Otis, Aidan, Brandon</div>
                <div class="post-date">April 22, 2025</div>
            </div>
        </div>
    </header>
    
    <img src="imgs/keyb_synth.jpeg" alt="Featured image" class="featured-image">
    
    <section class="introduction">
        <h2>Introduction</h2>
        <p>This DIY digital synthesizer and drum set project is perfect for any music enthusiast, 
            hacker, or programmers who are interested in digital signal processing (DSP), modern music production, electronics and programming.
            Use an Arduino and Rasperry PI Pico (optional) to create your own DJ deck, complete with a synthesizer, effects (attack, delay, sustain, release)
            , keyboard and drums. Develop some applied practical skills and add your own twists following along with this project!
        </p>
        
        <blockquote>
            "The most exciting phrase to hear in science, the one that heralds new discoveries, is not 'Eureka!' but 'That's funny...'" - Isaac Asimov
        </blockquote>
    </section>

    <section class="required-materials">
        <h2>What you'll need:</h2>
        <p>Below is a table of the main parts you will need to create the basic elements of this project. Don't fret! If you do not have exactly resistors or capacitors, you can experiment with designing your own filters, etc.</p>
        
        <table class="components-table">
            <thead>
                <tr>
                    <th>Component</th>
                    <th>Quantity</th>
                    <th>Specifications</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <!-- Core Electronics -->
                <tr class="section-header">
                    <td colspan="4"><strong>Core Electronics</strong></td>
                </tr>
                <tr>
                    <td>Arduino Nano 33 IOT</td>
                    <td>1</td>
                    <td>Or compatible microcontroller (Uno, etc.)</td>
                    <td>Main processor for the synthesizer</td>
                </tr>
                <tr>
                    <td>Raspberry PI Pico</td>
                    <td>1</td>
                    <td>Or compatible microcontroller</td>
                    <td>Main processor for drums and GUI</td>
                </tr>
                <tr>
                    <td>Breadboard</td>
                    <td>1</td>
                    <td>Full-size recommended, multiple may be helpful</td>
                    <td>For prototyping the circuit</td>
                </tr>
                <tr>
                    <td>Jumper Wires</td>
                    <td>20+</td>
                    <td>Various lengths, female connectors may be helpful</td>
                    <td>Connecting components</td>
                </tr>
                
                <!-- Keyboard/Input Section -->
                <tr class="section-header">
                    <td colspan="4"><strong>Keyboard/Input Components</strong></td>
                </tr>
                <tr>
                    <td>Keypad</td>
                    <td>1</td>
                    <td>Alternatively use 8+ push buttons</td>
                    <td>Keyboard keys</td>
                </tr>
                <tr>
                    <td>Potentiometers</td>
                    <td>6</td>
                    <td>10kΩ linear</td>
                    <td>Parameter controls for keyboard (attack, sustain, release, etc.)</td>
                </tr>
                <tr>
                    <td>Pull-down Resistors</td>
                    <td>8+</td>
                    <td>10kΩ</td>
                    <td>For button debouncing (only necessary if you use push-buttons rathe than keypad)</td>
                </tr>
                
                <!-- Synthesizer/Sound Generation -->
                <tr class="section-header">
                    <td colspan="4"><strong>Synthesizer Components</strong></td>
                </tr>
                <tr>
                    <td>Digital to Analogue Converter (DAC)</td>
                    <td>1</td>
                    <td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/22250A.pdf">MCP499</a> (12 bit DAC) or similar</td>
                    <td>Signal generation</td>
                </tr>
                <tr>
                    <td>Op-Amp</td>
                    <td>1</td>
                    <td><a href="https://www.analog.com/en/products/max417.html">MAX417</a> or similar</td>
                    <td>DAC signal conditioning</td>
                </tr>
                
                <tr>
                    <td>Resistors</td>
                    <td>2</td>
                    <td>10kΩ</td>
                    <td>For RC filter</td>
                </tr>
                <tr>
                    <td>Capacitor</td>
                    <td>1</td>
                    <td>1μF</td>
                    <td>For RC filter</td>
                </tr>
                
                <!-- Output Section -->
                <tr class="section-header">
                    <td colspan="4"><strong>Output Components</strong></td>
                </tr>
                <tr>
                    <td>Speaker</td>
                    <td>1</td>
                    <td>8Ω</td>
                    <td>Audio output</td>
                </tr>
                <tr>
                    <td>Audio Power Amplifier</td>
                    <td>1</td>
                    <td><a href= "https://www.ti.com/lit/ds/symlink/lm386.pdf">LM386N</a> or similar</td>
                    <td>Amplify audio signal</td>
                </tr>

                <td>Resistors</td>
                    <td>1</td>
                    <td>10kΩ</td>
                    <td>For power amp.</td>
                </tr>
                <td>Potentiometer</td>
                    <td>1</td>
                    <td>500kΩ</td>
                    <td>For Volume control</td>
                </tr>
                <tr>
                    <td>Capacitors</td>
                    <td>2</td>
                    <td>0.33μF, 220μF</td>
                    <td>For power amp.</td>
                </tr>
                
                <!-- GUI Components -->
                <tr class="section-header">
                    <td colspan="4"><strong>GUI Components</strong></td>
                </tr>
                <tr>
                    <td>OLED SPI Display</td>
                    <td>1</td>
                    <td>Any display that uses  Adafruit SSD1306 drivers <a href= "https://midasdisplays.com/shop/oled/oled-graphic/mdob128064bv-ws/"> e.g. MDOB128064BV-WS</a></td> 
                    <td>Display synthesizer parameters</td>
                </tr>
                <tr>
                    <td>Joystick</td>
                    <td>1</td>
                    <td>With push button <a href= "https://cdn.velleman.eu/downloads/29/vma315_a4v01.pdf"> e.g. VMA315</a></td>
                    <td>Menu navigation</td>
                </tr>

                <!-- Drum Section -->
                <tr class="section-header">
                    <td colspan="4"><strong>Drum Machine Components</strong></td>
                </tr>
                <tr>
                    <td>Touch sensor</td>
                    <td>4</td>
                    <td>Capacitive touch sensor such as <a href= "https://wiki.dfrobot.com/DFRobot_Capacitive_Touch_Sensor_SKU_DFR0030">DFRobot v2</a></td>
                    <td>Drum trigger pads</td>
                </tr>
            </tbody>
        </table>
    </section>
    
    <section class="project-overview">
        <h2>Project Overview</h2>
        <p>The main goal of this project was to utilize an analogue 
            component with an embedded component to create a system that 
            functionally produces and processes audio signals for musical applications. 
            Our system integrates the envelope components of the synthesizer 
            with the touch pads of the drum set to create a model of a DJ set that 
            allows for real-time sound creation and manipulation. This project 
            demonstrates the use of practical applications in circuit design as well
             as developing and processing audio signals for output, combining analog 
             signal conditioning with digital control systems.</p>
    </section>

    <section class="Lesson 1: Play around with sound.">
        <h2>Lesson 1: Play around with sound.</h2>
        <p>Originally we set out to make a vocoder for this project, but after much testing and consideration we decided to 
            pivot. Some of the elements we built however, remained useful. The first thing we built was an audio power amplifier, 
            so that we could experiment with playing different sounds through it, and how different filters would affect the audio.
            You can try connecting the <strong>green wire</strong> to different types of input and playing with the volume controls.

            <object type="image/svg+xml" data="interactive_elems/power_amplifier.svg" class="project-image">
                Your browser does not support SVG
            </object>

            <ul>
                <li><strong>LM386 IC:</strong> This integrated circuit amplifies the weak audio signal to a level that can drive a speaker.</li>
                
                <li><strong>500kΩ Potentiometer:</strong> This serves as our volume control, allowing us to adjust the amount of audio signal that reaches the amplifier. Turning this knob adjusts the amplitude of the output sound.</li>
                
                <li><strong>0.33μF Capacitor (Input):</strong> This capacitor blocks DC voltage while allowing AC audio signals to pass through, preventing DC offset from affecting the amplifier.</li>
                
                <li><strong>220μF Capacitor (Output):</strong> This large electrolytic capacitor couples the amplified audio signal to the speaker while blocking DC current.</li>
                
                <li><strong>8Ω Speaker:</strong> The final component in our chain converts the electrical signal from the amplifier into sound waves we can hear. The 8Ω impedance matches well with the LM386's output characteristics.</li>
            </ul>
            To experiment with the power amp, you can connect the input of the circuit to a PWM pin on an Arduino and use the "tone.h" library to play different frequencies.
        
        </p>
    </section>

    <section class="Lesson 2:  Tunable Polysynth with ADSR">
        <h2>Lesson 2: Tunable Polysynth with ADSR</h2>
        <p>
            Our goal in this lesson is to turn eight push‑buttons (or a tiny
            telephone‑style keypad) into a <strong>two‑voice digital synthesizer</strong>
            that feels surprisingly “analogue” thanks to a full ADSR envelope and
            rich lookup‑table waveform.  Everything runs on the Arduino Nano 33 IoT
            driving an <em>MCP4922</em> 12‑bit DAC, filtered, then boosted by a modest
            op‑amp/LM386 stage.  When you finish this page you’ll be able to play
            chords, tweak attack &amp; release in real time, and hear clean,
            artefact‑free notes through a speaker.
        </p>
        

        <img src="interactive_elems/SYNTH_bb.svg"
             alt="Poly‑synth build photo"
             class="project-image">
        <div class="caption">Fig 3: Prototype synth on breadboard with keypad and six potentiometers.</div>

        
        <h3>Controls at a glance</h3>
        <ul>
            <li><strong>Pot A&nbsp;(Fine Tune)</strong> – shifts the whole scale up or
                down about ±40 %. Great for quick pitch‑bend effects or matching other
                instruments.</li>
            <li><strong>Pot B&nbsp;(Semitone)</strong> – nudges each note in 25‑cent
                steps across ±3 semitones. Handy for temperament experiments.</li>
            <li><strong>Pot C&nbsp;(Attack)</strong> – how fast the note rises from
                silence to full level (0.1 ms → 200 ms).</li>
            <li><strong>Pot D&nbsp;(Decay)</strong> – rate that the level slides down
                to the sustain plateau (captured per note).</li>
            <li><strong>Pot E&nbsp;(Sustain)</strong> – steady volume while a key is
                held (0 → 100 %). Also captured per note so later tweaks don’t affect
                existing sustains.</li>
            <li><strong>Pot F&nbsp;(Release)</strong> – fall‑off time once the key is
                released (0.1 ms → 200 ms).</li>
        </ul>
        
        <p>
            The <strong>eight note buttons</strong> map to a one‑octave A‑major scale:
            A4&nbsp;→&nbsp;A5 (A, B, C♯, D, E, F♯, G♯, A).  
            Because we store the scale as offsets from A4, the synth can easily transpose.
            Use the <strong>Oct ▲</strong> and <strong>Oct ▼</strong> buttons (pins A7
            &amp; A6) to shift the entire keyboard ±4 octaves.
        </p>
        
        <h3>Circuit overview</h3>
        <p>
            The Nano’s SPI bus clocks data into the MCP4922 at 8 MHz.  We use only
            channel A (12‑bit resolution).  A simple RC low‑pass pulls the
            stair‑stepped output down to audio‑bandwidth, and a unity‑gain
            <em>MAX417</em> buffers the line before it reaches the LM386 power amp.
            Frequency pots (A0 &amp; A1) feed 10‑bit ADC readings directly into the
            firmware’s tuning maths, while four more pots land on A2–A5 for the
            envelope knobs.  Eight buttons on D2‑D9 trigger the note logic; two
            extra buttons on A6/A7 bump the octave.
        </p>
        
        <table class="components-table">
            <thead><tr><th>Poly‑Synth‑only parts</th><th>Qty</th><th>Notes</th></tr></thead>
            <tbody>
                <tr><td>MCP4922 12‑bit DAC</td><td>1</td>
                    <td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/22250A.pdf">datasheet</a>,
                        channel A used</td></tr>
                <tr><td>MAX417 (or any rail‑to‑rail op‑amp)</td><td>1</td>
                    <td>Unity buffer / RC low‑pass</td></tr>
                <tr><td>10 kΩ potentiometers</td><td>6</td>
                    <td>Attack, Decay, Sustain, Release, Fine‑tune, Semitone</td></tr>
                <tr><td>12‑key silicone keypad<br>(or 8 push‑buttons)</td><td>1</td>
                    <td>Note triggers</td></tr>
                <tr><td>RC filter</td><td>1 × 10 kΩ + 1 µF</td>
                    <td>1st‑order low‑pass ≈ 16 Hz f<sub>c</sub></td></tr>
                <tr><td>LM386, speaker, vol pot</td><td>1 set</td>
                    <td>Reuse from Lesson 1 amp</td></tr>
            </tbody>
        </table>
        
        <h3>Firmware deep‑dive</h3>
        
        <details>
        <summary><strong>Code anatomy (click to expand)</strong></summary>
        <ul>
            <li><code>rich_lookup_table[256]</code> – a pre‑cooked additive‑synthesis
                waveform. 256 samples keeps the phase counter byte‑sized and speeds
                table fetches.</li>
        
            <li><code>struct Voice</code> – holds everything per note:
                <ul>
                    <li><em>phase / phaseIncrement</em> – fractional 0‑255 counter that
                        indexes the table.</li>
                    <li><em>envState / envLevel</em> – live ADSR state machine.</li>
                    <li><em>decayTarget &amp; sustainLevel</em> – captured from the pots
                        at note‑on so decay really <em>isn’t</em> tied to sustain.</li>
                </ul>
            </li>
        
            <li><code>updateEnvelope()</code> – runs every sample. Key idea: during
                DECAY we subtract <code>env_decay</code> until <code>envLevel</code>
                hits <code>decayTarget</code>, then snap to
                <code>sustainLevel</code>. RELEASE is a straight linear fall under
                <code>env_release</code>.</li>
        
            <li><code>generateAudio()</code>
                <ul>
                    <li>Calls <code>updateEnvelope()</code>.</li>
                    <li>**Pitch math:** <code>phase += phaseInc</code>; if over 255,
                        wrap.</li>
                    <li>Weighted mix = 0.55 × voice0 + 0.45 × voice1. (Add 2048 to
                        recenter for the DAC.)</li>
                </ul>
            </li>
        
            <li><code>checkInputs()</code> – polled every 100 ms.
                <ul>
                    <li>Updates <em>baseFreqMultiplier</em> (fine tune) and
                        <em>semitoneRatio</em> from the pots.</li>
                    <li>Live‑tweaks Attack &amp; Release rates.</li>
                    <li>Debounces 8 note buttons + octave up/down.</li>
                </ul>
            </li>
        
            <li><code>triggerNote()</code>
                <ul>
                    <li>If the same note already plays, it re‑arms that voice (re‑phase,
                        envelope back to ATTACK).</li>
                    <li>Otherwise chooses a free/round‑robin voice.</li>
                    <li>Computes frequency&nbsp;→ <code>phaseIncrement</code> via  
                        <br><code>(freq × 8.4) / 1000</code>, clipped ≤ 128.</li>
                    <li>Captures decay &amp; sustain pot values into the voice.</li>
                </ul>
            </li>
        
            <li><code>updateAllVoiceFrequencies()</code> – called when tuning pots or
                octave change: recalculates every active voice’s
                <code>phaseIncrement</code> so chords stay in tune.</li>
        </ul>
        </details>
        
        <h3>Key techniques</h3>
        <ul>
            <li><strong>Per‑note phase randomisation</strong> – new note seeds its phase
                from <code>seedValue % 256</code> so two identical notes don’t cancel.</li>
            <li><strong>Slew‑free tuning</strong> – by updating the
                <code>phaseIncrement</code> directly, pitch bends have no zipper noise.</li>
            <li><strong>Pitch droop compensation (optional)</strong> – if you notice
                frequencies sagging during DECAY or RELEASE, uncomment the
                <code>// BOOST</code> line in <code>generateAudio()</code> and set
                <code>currentPhaseInc *= 1.05;</code>.</li>
        </ul>
        
        <h3>Build &amp; test</h3>
        <ol>
            <li>Wire the DAC: SCK→D13, MOSI→D11, CS→D10, LDAC→GND, V<sub>REF</sub> &amp;
                V<sub>DD</sub>→3V3.</li>
            <li>RC low‑pass 10 kΩ + 1 µF, then buffer with MAX417 (or TLV2462).</li>
            <li>Feed the op‑amp into your LM386 amp from Lesson 1.</li>
            <li>Hook up six pots (A0–A5) and keypad/buttons (D2–D9).</li>
            <li>Flash the sketch below, open Serial Plotter (you’ll see the envelope),
                then play chords &amp; twist knobs.</li>
        </ol>
        
        <div class="code-container">
            <div class="code-header">
                <span>Arduino Poly‑Synth</span>
                <span class="code-language">cpp</span>
            </div>
            <pre><code class="language-cpp">
                #include &lt;SPI.h&gt;

                    // -------------------- Pin Definitions --------------------
                    #define CS_PIN           10
                    #define OCT_UP_PIN       A7
                    #define OCT_DOWN_PIN     A6
                    #define FREQ_TUNE_PIN    A0
                    #define SEMITONE_TUNE_PIN A1
                    // ADSR pots on A2–A5:
                    #define ATTACK_POT       A2    // Attack
                    #define DECAY_POT        A3    // Decay (used here to set decay rate only)
                    #define SUSTAIN_POT      A4    // Sustain (captured at note-on)
                    #define RELEASE_POT      A5    // Release
                    
                    // Note buttons (pins D2–D9)
                    const uint8_t NOTE_PINS[] = {2, 3, 4, 5, 6, 7, 8, 9};
                    const uint8_t NUM_NOTES = sizeof(NOTE_PINS);
                    
                    // ------------------- DAC & Frequency Scaling -------------------
                    #define DAC_CONFIG       0x3000  // For MCP4922 DAC: channel A, 1x gain, active
                    #define FREQUENCY_SCALING 8.4    // Empirically determined scaling factor
                    
                    // ----------------------- Waveform Table -------------------------
                    // 256-point lookup table for a rich waveform (12-bit, centered at 2048)
                    const int rich_lookup_table[256] = {
                      2048, 2207, 2364, 2520, 2672, 2820, 2963, 3101,
                      3231, 3354, 3469, 3576, 3672, 3760, 3837, 3904,
                      3961, 4008, 4044, 4071, 4088, 4095, 4094, 4084,
                      4066, 4042, 4011, 3974, 3932, 3886, 3837, 3785,
                      3732, 3677, 3623, 3568, 3515, 3464, 3415, 3368,
                      3325, 3285, 3249, 3216, 3188, 3164, 3145, 3129,
                      3117, 3109, 3104, 3102, 3103, 3107, 3112, 3119,
                      3127, 3135, 3144, 3152, 3160, 3166, 3171, 3175,
                      3176, 3175, 3171, 3164, 3155, 3143, 3128, 3110,
                      3089, 3066, 3040, 3012, 2982, 2950, 2917, 2883,
                      2848, 2813, 2778, 2743, 2709, 2676, 2644, 2614,
                      2585, 2559, 2534, 2512, 2492, 2474, 2459, 2446,
                      2436, 2427, 2421, 2416, 2413, 2411, 2410, 2410,
                      2410, 2411, 2411, 2412, 2411, 2409, 2407, 2402,
                      2396, 2389, 2379, 2367, 2353, 2337, 2319, 2299,
                      2277, 2253, 2227, 2200, 2171, 2141, 2111, 2079,
                      2048, 2017, 1985, 1955, 1925, 1896, 1869, 1843,
                      1819, 1797, 1777, 1759, 1743, 1729, 1717, 1707,
                      1700, 1694, 1689, 1687, 1685, 1684, 1685, 1685,
                      1686, 1686, 1686, 1685, 1683, 1680, 1675, 1669,
                      1660, 1650, 1637, 1622, 1604, 1584, 1562, 1537,
                      1511, 1482, 1452, 1420, 1387, 1353, 1318, 1283,
                      1248, 1213, 1179, 1146, 1114, 1084, 1056, 1030,
                      1007, 986, 968, 953, 941, 932, 925, 921,
                      920, 921, 925, 930, 936, 944, 952, 961,
                      969, 977, 984, 989, 993, 994, 992, 987,
                      979, 967, 951, 932, 908, 880, 847, 811,
                      771, 728, 681, 632, 581, 528, 473, 419,
                      364, 311, 259, 210, 164, 122, 85, 54,
                      30, 12, 2, 1, 8, 25, 52, 88,
                      135, 192, 259, 336, 424, 520, 627, 742,
                      865, 995, 1133, 1276, 1424, 1576, 1732, 1889
                    };
                    
                    // -------------------- Base Frequencies ------------------------
                    // For notes A4, B4, C5, D5, E5, F5, G5, A5 (using exact frequency ratios from A4=440Hz)
                    const float BASE_FREQUENCIES[] = {
                      440.00, 493.88, 523.25, 587.33, 659.26, 698.46, 783.99, 880.00
                    };
                    
                    // -------------------- ADSR Definitions -------------------------
                    // Envelope states:
                    #define ENV_IDLE    0
                    #define ENV_ATTACK  1
                    #define ENV_DECAY   2
                    #define ENV_SUSTAIN 3
                    #define ENV_RELEASE 4
                    
                    // Global ADSR rates for attack, decay, and release (decay rate remains global)
                    float env_attack  = 0.005;   // Attack rate (increment per sample)
                    float env_decay   = 0.005;   // Decay rate (decrement per sample)
                    float env_release = 0.005;   // Release rate (decrement per sample)
                    
                    // In order to decouple decay from sustain, we add per‑voice fields.
                    // (When a note is triggered the current DECAY and SUSTAIN pot values are captured.)
                    struct Voice {
                      bool active;           // Is the voice active?
                      float phase;           // Current phase (0–256, fractional)
                      float phaseIncrement;  // Phase increment per sample (set by frequency)
                      uint8_t noteIndex;     // Note index (0–7)
                      float baseFreq;        // Frequency before scaling adjustments
                      float envLevel;        // Current envelope level (0.0 to 1.0)
                      uint8_t envState;      // ADSR state (IDLE, ATTACK, etc.)
                      float decayTarget;     // Target level for decay (captured at note-on)
                      float sustainLevel;    // Sustain level (captured at note-on)
                    };
                    
                    Voice voices[2] = {
                      {false, 0.0, 0.0, 0, 0.0, 0.0, ENV_IDLE, 0.0, 0.0},
                      {false, 0.0, 0.0, 0, 0.0, 0.0, ENV_IDLE, 0.0, 0.0}
                    };
                    uint8_t currentVoice = 0;       // For round-robin selection
                    int8_t octaveOffset = 0;        // Octave shift (-3 to +4)
                    uint8_t lastButtonState[NUM_NOTES] = {0}; // For debouncing buttons
                    uint32_t lastOctaveChangeTime = 0;
                    uint32_t lastNoteChangeTime[NUM_NOTES] = {0};
                    float baseFreqMultiplier = 1.0; // Fine tuning multiplier
                    float semitoneRatio = 1.0595;   // Ratio for one semitone
                    uint32_t seedValue = 0;         // For phase randomization
                    
                    // -------------------- Update Envelope -------------------------
                    // During DECAY the envelope decreases from 1.0 to the per‑voice decay target, then jumps to the captured sustain level.
                    inline void updateEnvelope(Voice &v) {
                      if (v.envState == ENV_ATTACK) {
                        v.envLevel += env_attack;
                        if (v.envLevel >= 1.0) {
                          v.envLevel = 1.0;
                          v.envState = ENV_DECAY;
                        }
                      } else if (v.envState == ENV_DECAY) {
                        v.envLevel -= env_decay;
                        if (v.envLevel <= v.decayTarget) {    // Use per‑voice decay target
                          v.envLevel = v.sustainLevel;        // Jump to the captured sustain level
                          v.envState = ENV_SUSTAIN;
                        }
                      } else if (v.envState == ENV_SUSTAIN) {
                        v.envLevel = v.sustainLevel;
                      } else if (v.envState == ENV_RELEASE) {
                        v.envLevel -= env_release;
                        if (v.envLevel <= 0.0) {
                          v.envLevel = 0.0;
                          v.envState = ENV_IDLE;
                          v.active = false;
                        }
                      }
                    }
                    
                    // -------------------- DAC Output -------------------------
                    inline void writeToDAC(uint16_t value) {
                      uint16_t command = DAC_CONFIG | (value & 0x0FFF);
                      digitalWrite(CS_PIN, LOW);
                      SPI.transfer(command >> 8);
                      SPI.transfer(command & 0xFF);
                      digitalWrite(CS_PIN, HIGH);
                    }
                    
                    // -------------------- Audio Generation -------------------------
                    // This function is called repeatedly from loop() to generate audio.
                    inline int generateAudio() {
                      float mixedAC = 0.0;
                      const float weight0 = 0.55;
                      const float weight1 = 0.45;
                      for (uint8_t i = 0; i < 2; i++) {
                        if (!voices[i].active) continue;
                        updateEnvelope(voices[i]);
                        voices[i].phase += voices[i].phaseIncrement;
                        while (voices[i].phase >= 256)
                          voices[i].phase -= 256;
                        uint8_t sampleIndex = (uint8_t)voices[i].phase;
                        int sample = rich_lookup_table[sampleIndex];
                        float acSample = (sample - 2048) * voices[i].envLevel;
                        if (i == 0)
                          mixedAC += weight0 * acSample;
                        else
                          mixedAC += weight1 * acSample;
                      }
                      return (int)(mixedAC + 2048);
                    }
                    
                    // -------------------- Update Active Voice Frequencies -------------------------
                    void updateAllVoiceFrequencies() {
                      float baseA4 = 440.0 * baseFreqMultiplier;
                      float noteFrequencies[NUM_NOTES];
                      int semitoneDistance[] = {0, 2, 3, 5, 7, 8, 10, 12};
                      for (int i = 0; i < NUM_NOTES; i++) {
                        noteFrequencies[i] = baseA4 * pow(semitoneRatio, semitoneDistance[i]);
                      }
                      for (uint8_t v = 0; v < 2; v++) {
                        if (voices[v].active) {
                          float frequency = noteFrequencies[voices[v].noteIndex];
                          if (octaveOffset > 0) {
                            for (int8_t j = 0; j < octaveOffset; j++)
                              frequency *= 2.0;
                          } else if (octaveOffset < 0) {
                            for (int8_t j = 0; j > octaveOffset; j--)
                              frequency *= 0.5;
                          }
                          voices[v].baseFreq = frequency;
                          float scalingFactor = FREQUENCY_SCALING;
                          if (frequency > 2000)
                            scalingFactor *= 1.1;
                          float newPhaseInc = (frequency * scalingFactor) / 1000.0;
                          if (newPhaseInc > 128)
                            newPhaseInc = 128;
                          if (fabs(newPhaseInc - voices[v].phaseIncrement) > 0.1)
                            voices[v].phaseIncrement = newPhaseInc;
                        }
                      }
                    }
                    
                    // -------------------- Input Processing -------------------------
                    void checkInputs() {
                      // --- Frequency and Tuning ---
                      int freqTune = analogRead(FREQ_TUNE_PIN);
                      baseFreqMultiplier = 0.6 + (0.8 * freqTune / 1023.0);
                      
                      int semitoneTune = analogRead(SEMITONE_TUNE_PIN);
                      semitoneRatio = pow(2.0, (0.85 + (0.3 * semitoneTune / 1023.0)) / 12.0);
                      
                      // --- ADSR Controls for Attack & Release (global) ---
                      int attackPot = analogRead(ATTACK_POT);
                      int releasePot = analogRead(RELEASE_POT);
                      env_attack  = 0.0001 + 0.0002 * (attackPot / 1023.0);
                      env_release = 0.0001 + 0.0002 * (releasePot / 1023.0);
                      
                      // For decay and sustain, we capture per-note values at note-on.
                      // Optionally update live sustain for voices in sustain:
                      int sustainPot = analogRead(SUSTAIN_POT);
                      float liveSustain = (float)sustainPot / 1023.0;
                      for (uint8_t v = 0; v < 2; v++) {
                        if (voices[v].active && voices[v].envState == ENV_SUSTAIN) {
                          voices[v].sustainLevel = liveSustain;
                          voices[v].envLevel = liveSustain;
                        }
                      }
                      
                      // --- Update Active Voice Frequencies ---
                      if (voices[0].active || voices[1].active)
                        updateAllVoiceFrequencies();
                      
                      // --- Octave Control ---
                      uint32_t currentTime = millis();
                      if (currentTime - lastOctaveChangeTime > 200) {
                        if (digitalRead(OCT_UP_PIN) == LOW && octaveOffset < 4) {
                          octaveOffset++;
                          lastOctaveChangeTime = currentTime;
                          updateAllVoiceFrequencies();
                        } else if (digitalRead(OCT_DOWN_PIN) == LOW && octaveOffset > -3) {
                          octaveOffset--;
                          lastOctaveChangeTime = currentTime;
                          updateAllVoiceFrequencies();
                        }
                      }
                      
                      // --- Note Button Handling (with debouncing) ---
                      for (uint8_t i = 0; i < NUM_NOTES; i++) {
                        uint8_t buttonState = digitalRead(NOTE_PINS[i]);
                        if (buttonState != lastButtonState[i] && (currentTime - lastNoteChangeTime[i] > 20)) {
                          lastNoteChangeTime[i] = currentTime;
                          lastButtonState[i] = buttonState;
                          if (buttonState == LOW)
                            triggerNote(i);
                          else
                            releaseNote(i);
                        }
                      }
                    } // <-- End of checkInputs()
                    
                    // -------------------- Note Triggering -------------------------
                    void triggerNote(uint8_t noteIndex) {
                      // If the note is already active, reinitialize that voice.
                      for (uint8_t v = 0; v < 2; v++) {
                        if (voices[v].active && voices[v].noteIndex == noteIndex) {
                          float baseA4 = 440.0 * baseFreqMultiplier;
                          int semitoneDistance[] = {0, 2, 3, 5, 7, 8, 10, 12};
                          float frequency = baseA4 * pow(semitoneRatio, semitoneDistance[noteIndex]);
                          if (octaveOffset > 0) {
                            for (int8_t j = 0; j < octaveOffset; j++)
                              frequency *= 2.0;
                          } else if (octaveOffset < 0) {
                            for (int8_t j = 0; j > octaveOffset; j--)
                              frequency *= 0.5;
                          }
                          voices[v].baseFreq = frequency;
                          float scalingFactor = FREQUENCY_SCALING;
                          if (frequency > 2000)
                            scalingFactor *= 1.1;
                          float phaseInc = (frequency * scalingFactor) / 1000.0;
                          if (phaseInc > 128)
                            phaseInc = 128;
                          voices[v].phaseIncrement = phaseInc;
                          voices[v].phase = (seedValue % 256);
                          voices[v].envLevel = 0.0;
                          voices[v].envState = ENV_ATTACK;
                          // Capture decay and sustain settings at note-on
                          voices[v].decayTarget = 0.2 + 0.7 * (analogRead(DECAY_POT) / 1023.0);
                          voices[v].sustainLevel = (float)analogRead(SUSTAIN_POT) / 1023.0;
                          return;
                        }
                      }
                      
                      // Otherwise, choose a free voice (or use round-robin if both are active)
                      uint8_t voiceIndex = 0;
                      if (voices[0].active && voices[1].active) {
                        voiceIndex = currentVoice;
                        currentVoice = 1 - currentVoice;
                      } else if (voices[0].active) {
                        voiceIndex = 1;
                      } else {
                        voiceIndex = 0;
                      }
                      
                      float baseA4 = 440.0 * baseFreqMultiplier;
                      int semitoneDistance[] = {0, 2, 3, 5, 7, 8, 10, 12};
                      float frequency = baseA4 * pow(semitoneRatio, semitoneDistance[noteIndex]);
                      if (octaveOffset > 0) {
                        for (int8_t j = 0; j < octaveOffset; j++)
                          frequency *= 2.0;
                      } else if (octaveOffset < 0) {
                        for (int8_t j = 0; j > octaveOffset; j--)
                          frequency *= 0.5;
                      }
                      voices[voiceIndex].baseFreq = frequency;
                      float scalingFactor = FREQUENCY_SCALING;
                      if (frequency > 2000)
                        scalingFactor *= 1.1;
                      float phaseInc = (frequency * scalingFactor) / 1000.0;
                      if (phaseInc > 128)
                        phaseInc = 128;
                      voices[voiceIndex].phase = (seedValue % 256);
                      voices[voiceIndex].phaseIncrement = phaseInc;
                      voices[voiceIndex].active = true;
                      voices[voiceIndex].noteIndex = noteIndex;
                      voices[voiceIndex].envLevel = 0.0;
                      voices[voiceIndex].envState = ENV_ATTACK;
                      // Capture independent decay and sustain values on note-on
                      voices[voiceIndex].decayTarget = 0.2 + 0.7 * (analogRead(DECAY_POT) / 1023.0);
                      voices[voiceIndex].sustainLevel = (float)analogRead(SUSTAIN_POT) / 1023.0;
                    }
                    
                    // -------------------- Note Release -------------------------
                    void releaseNote(uint8_t noteIndex) {
                      // Initiate the release phase for the voice playing this note.
                      for (uint8_t v = 0; v < 2; v++) {
                        if (voices[v].active && voices[v].noteIndex == noteIndex) {
                          voices[v].envState = ENV_RELEASE;
                          break;
                        }
                      }
                    }
                    
                    // -------------------- DAC Initialization -------------------------
                    void setup() {
                      // Set up DAC chip select
                      pinMode(CS_PIN, OUTPUT);
                      digitalWrite(CS_PIN, HIGH);
                      
                      // Initialize SPI for DAC
                      SPI.begin();
                      SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));
                      
                      // Set up note buttons with pull-ups
                      for (uint8_t i = 0; i < NUM_NOTES; i++) {
                        pinMode(NOTE_PINS[i], INPUT_PULLUP);
                      }
                      // Set up octave control buttons
                      pinMode(OCT_UP_PIN, INPUT_PULLUP);
                      pinMode(OCT_DOWN_PIN, INPUT_PULLUP);
                      
                      // Initialize random seed (for phase randomization)
                      seedValue = micros();
                      
                      // Start with a silent output
                      writeToDAC(2048);
                    }
                    
                    // -------------------- Main Loop -------------------------
                    void loop() {
                      // Generate and output audio as fast as possible
                      writeToDAC(generateAudio());
                      
                      // Check inputs about every 100ms
                      static uint32_t lastPotRead = 0;
                      if (millis() - lastPotRead > 100) {
                        lastPotRead = millis();
                        checkInputs();
                      }
                      
                      // Update random seed occasionally
                      seedValue = seedValue * 1664525L + 1013904223L;
                    }
                    
            </code></pre>
        </div>
               
    
        <section class="Lesson 4: Converting YouTube Videos to Drum Samples.">
            <h2>Lesson 4: Converting YouTube Videos to Drum Samples.</h2>
            <p>
                A fun thing to do is to create your own drum samples from sounds/songs that you like. The easiest way to do this is to
                download an <code>`.mp3`</code> version (or use your own mp3) of a song/sound from YouTube. Sites such as <a href="https://youtubemp3free.com/en/">this one</a> can convert them for free.
                Once you have an mp3 file, it needs to be converted to <code>`.wav`</code> format. Sites such as <a href="https://www.freeconvert.com/mp3-to-wav">this one</a> can convert them for free. 
                <br>
                <br>
                We wrote a script that converts the wav file into a format that is compatible with our drum kit: an array of 16-bit integers (same format as drum samples).
                The script generates a C header file that can be included in the drum kit code to make that sample available. Samples are limited to 4 seconds, which allowed us to fit three samples onto the Pico due to memory contraints.
    
    
                <div class="code-container">
                    <div class="code-header">
                        <span>Python code for song converter.</span>
                        <span class="code-language">python3</span>
                    </div>
                    <pre><code id="song-converter" class="language-python" data-src="code_snippets/song_converter.py"></code></pre>
                </div>
                Below is the output header file for a "Rick-roll". By including this in the drum kit code, it can be used as a drum 
                sample.
                <div class="code-container">
                    <div class="code-header">
                        <span>Song converted into header.</span>
                        <span class="code-language">C</span>
                    </div>
                    <pre><code id="rick-roll-header" class="language-c" data-src="code_snippets/rick_roll.h"></code></pre>
                </div>
            </p>
        </section>
    
    <section class="Lesson 5: Create a GUI.">
        <h2>Lesson 5: Create a GUI.</h2>
        <p>
            A graphical user interface (GUI) can really improve the user experience, here the GUI serves a few functions. Firstly, it displays the current properties set on the ADSR for tuning.
            It also functions as an oscilloscope, and can display the wave that is being generated by the keyboard synthesizer.
            By using the click functionality on the joystick, a user can select from a list of preprogrammed drum loops, which will start playing on the drum via the Pico!
            Navigation through the GUI works with the flick of the joystick, by flicking left or right, you can cycle through the different screens.
            By flicking up and down, you can cycle through the different preprogrammed drum loops and songs.
            <object type="image/svg+xml" data="interactive_elems/synth_GUI_bb.svg" class="project-image">
                Your browser does not support SVG
            </object>
            <ul>
                <li><strong>Arduino:</strong> The Arduino Uno controlls the GUI states, sends state updates to the Pico and refreshes the OLED display. This could be run on the same Arduino as the synthesizer or even on the Pico. We did experiment with running the GUI on the second core of the Pico, but because of a lack of analogue input GPIO pins, and no library support for the Adafruit OLED displays, this did not work. It would have been simple to also run the GUI on the Arduino Nano, where the synthesizer runs, however, again because of a limit on GPIO pins and clock constraints (the Nano was not fast enough to get sufficient wave resolution and run the GUI) this was abandoned. If we were to do this project again, we would use just one microcontroller with more computational power to run the synthesizer and the GUI. </li>
                
                <li><strong>Joystick:</strong> The joystick is used to navigate the GUI through three analogue inputs: displacement in x, displacement in y, and clicking of the joystick. In the code there are limits defined for what displacement of the joystick is considered a 'flick'. These flicks are used to navigate through the different menus and also between songs/drum loops within menus. When a user wants to select a song, they can click in on the joystick. This click is debounced, and depending on the state of the screen (which drum loop/song they were hovering over), the selected drum loop/song will be updated. Every time a selection is updated this is passed to the Pico.</li>
                
                <li><strong>Output wires:</strong> The white, orange, ochre, and purple wires in the schematic (connected to digital GPIO pins) are the functinonal connections to the Pico. They relay the update drum/song choice to the Pico. In our implementation, this works simply but outputting a 'high' to a wire corresponding to each possible drum selection. In the future, it would be better to serialize the selection.</li>
                
                <li><strong>OLED display:</strong> The OlED display runs on the Adafruit SSD1306 library over serial peripheral interface (SPI). There is great support of this screen on the Arduino, using the SPI library and the Adafruit screen library. Using the built in functions of these libraries, custom screens can be drawn and displayed on the screen based on state variables. This is the main premise of the code implementation, discussed below.</li>
                
            </ul>


            <div class="code-container">
                <div class="code-header">
                    <span>Arduino Code for GUI</span>
                    <span class="code-language">C++</span>
                </div>
                <pre><code id="gui-arduino-code" class="language-cpp" data-src="code_snippets/gui_arduino_code.ino"></code></pre>
            </div>
            At it's core the GUI is driven by one state variable: <code>`screen_state`</code>, which ranges from 1-5, and denotes the current screen that will be displayed: a main menu, synthesizer controls, oscilloscope, song selector, and drum selector. The chooseScreen() function continuously reads the joystick's X-axis: pushing right increments <code>`screen_state`</code>, pushing left decrements it, and it wraps around when it goes beyond either end. Each loop iteration then calls <code>`drawScreen()`</code>, which dispatches to the appropriate drawing function for the current mode.
            For selecting and playing preprogrammed drum loops <code>`(screen_state == 5)`</code>, the joystick's Y-axis moves a highlighted box through up to four entries ("Money beat", "Hip-Hop", "Funk", "None"), while a click of the joystick button(debounced) commits a choice into <code>`selected_song`</code>. The selected song is conveyed to the Pico, to play the drums.
            Throughout the code, "dead-zone" thresholds prevent jitter when the joystick is centered, and brief delay(100) calls debounce menu transitions.
            
        </p>
    </section>


    <section class="How-Do-The-Components-Work?">
        <h2>How Do The Components Work?</h2>
        <p>The DJ set consists of these components:</p>
        <li>Keyboard Synthesizer featuring an ADSR (Attack, Decay, Sustain, Release) 
            envelope controller, a 12-key numeric keypad interface, operational amplifier 
            circuitry for signal conditioning, a Digital-to-Analog Converter (DAC) for
             waveform generation, and an Arduino microcontroller for processing and control.</li>
        <div style="text-align: center;">
            <img src="imgs/Labelled_Synth.jpeg" alt="labelled image" class="labelled-image" width="500" height="475" style="border: 3px solid black;">
        </div>
        
        <li>GUI features a real-time oscilloscope to vizualize the audio waveform, drum and
             synthesizer screens, percentage bars for amplitude monitoring, and song screen 
             to view the selected song from a list of preloaded audio sounds</li>

        <!-- need a labelled picture of the GUI here -->   
        
        <li>Drum Set including 4 touchpads to simulate snare, kick, hi-hat, and toms. It uses a Raspberry Pi Pico
            as the core controller, interfaced with an op amp, a digital-to-analogue converter (DAC), and a speaker
            to produce the drum sounds instantaneously.</li>
        <div style="text-align: center;">
            <img src="imgs/Labelled_Drums.jpg" alt="labelled imge" class="labelled-image" width="500" height="350" style="border: 3px solid black;">
        </div>
    </section>
    
    <section id="building-hardware">
        <h2>Building the Hardware</h2>
        <div style="text-align: center;">
            <img src="imgs/Full_DJ_Set_Picture.jpg" alt="labelled imge" class="labelled-image"width="750" height="500" style="border: 3px solid black;">
        </div>
        <p>Our DJ table consists of three main hardware components working together to
             create a complete music production system. This section contains detailed 
             information on how to construct and integrate the final components.</p>
        
        <div class="component-section">
            <h3>Summing Amplifier</h3>
            <div style="text-align: center;">
                <img src="imgs/NBMetadataCache.jpeg" alt="labelled imge" class="labelled-image" width="750" height="200">
            </div>
            <p>In order to combine all the sounds from the DJ set into a single speaker, a summing amplifier is used.
                This component takes 2 audio inputs, one from the drums and the other from synthesizer, and mixes 
                them into a single output signal that is then sent to the speaker.</p>
            </div>
            <div class="component-section">
                <h3>Execution</h3>
                <img src="/api/placeholder/800/350" alt="Fritzing of everything together" class="project-image">
                <p> The schematic above illustrates how all components are interconnected to form a cohesive audio system, 
                    representing the completed project fully integrated into a functional DJ set. On the right, the synthesizer 
                    circuit generates analog audio signals controlled by the ADSR, while the drum module on the left produces 
                    digital drum sounds that are converted to analog using a DAC. Both of these outputs are fed into a summing 
                    amplifier in the middle, which combines the signals into a single output that drives the speaker on the 
                    far left. The GUI, located on the blue tray above, has the ability to play prerecorded songs and beats, as 
                    well as display a simplified oscilloscope to visualize changes in the electrical signal over time. </p>
            </div>

        </div>
        

    </section>

    <section class="methodology">
        <h2>My Approach</h2>
        <p>To complete this project, I followed these steps:</p>
        
        <h3>Step 1: Research</h3>
        <p>I began by researching [topic] using resources from our school library and online sources. Some key resources included [mention books, websites, or articles].</p>
        
        <h3>Step 2: Planning</h3>
        <p>After gathering information, I created a plan for my project that included [describe your planning process].</p>
        
        <img src="/api/placeholder/800/350" alt="Planning diagram" class="project-image">
        <div class="caption">Fig 1: My initial project plan showing [what the image shows]</div>
        
        <h3>Step 3: Execution</h3>
        <p>With my plan in place, I began working on [describe what you did]. This involved [specific tasks or techniques].</p>
    </section>
    
    <section class="results">
        <h2>Results</h2>
        <p>After completing my project, I discovered [describe your findings or results]. The most interesting aspects were:</p>
        
        <img src="/api/placeholder/800/350" alt="Project result" class="project-image">
        <div class="caption">Fig 2: My final project showing [what the image shows]</div>
        
        <p>I was particularly proud of [specific achievement or aspect of your project].</p>
    </section>
    
    <section class="challenges">
        <h2>Challenges Faced</h2>
        <p>This project wasn't without its difficulties. Some challenges I encountered included:</p>
        <ul>
            <li><strong>Challenge 1:</strong> [Describe a challenge and how you overcame it]</li>
            <li><strong>Challenge 2:</strong> [Describe another challenge and how you overcame it]</li>
            <li><strong>Challenge 3:</strong> [Describe another challenge and how you overcame it]</li>
        </ul>
    </section>
    
    <section class="conclusion">
        <h2>Conclusion</h2>
        <p>Overall, this project taught me a lot about [topic]. I learned that [key insight 1] and discovered that [key insight 2]. If I were to do this project again, I would [what you would do differently].</p>
        
        <p>I would like to thank [acknowledge anyone who helped you] for their support and guidance throughout this project.</p>
    </section>
    
    <footer>
        <p>© 2025 Aidan, Ruairi, Otis & Brandon  | Trinity College Dublin</p>
        <p>Created for 3C10 - Circuits & Systems Design</p>
    </footer>
</body>
</html>